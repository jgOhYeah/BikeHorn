#!/usr/bin/env python3
# GUI libraries
import tkinter as tk                    
from tkinter import ttk
from tkinter import filedialog as fd
import tkinter.messagebox as tkmb
import webbrowser

# Graphs
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.patches import Patch
from matplotlib.lines import Line2D

# Serial
import serial.tools.list_ports
from serial.serialutil import SerialException
import serial

# Sound
import sounddevice as sd

# Optimising
import piecewise_regression
import fractions
import math

# General
import time
import numpy as np
import threading
from typing import Iterable, Tuple
import datetime

# TODO: Load / save a default settings file automatically (not necessary, but might be convenient)
# TODO: Guard against negative numbers in timer settings
# TODO: Standard deviation / different from those around a data point as a measure of uncertainty when fitting to avoid noise / didgy data

name = "Bike Horn Optimiser Tool"
version = "0.0.2"

class DataManager():
    """Class to handle all data and the loading and saving of it
    """
    def __init__(self, logging):
        self._filename = datetime.datetime.now().strftime("%Y%m_%H%M_BikeHornTest.npz")
        self._logging = logging
        self._to_call_on_update_sound = []
        self._to_call_on_update_settings = []
        self._settings = {}
        self._sound_data = []

    def get_filename(self):
        """Gets the filename for the current file (or an autogenerated one if not set)

        Returns:
            str: filename
        """
        return self._filename

    def set_filename(self, filename):
        """Sets the filename to use

        Args:
            filename (str): the filename to use
        """
        self._filename = filename
    
    def save_data(self, backup=False):
        """Writes the file containing the data
        """
        filename = self.get_filename()
        extra_log_info = ""
        if backup:
            filename = ".BACKUP_{}".format(filename)
            extra_log_info = " (as a backup)"

        metadata = {
            "date_time": datetime.datetime.now().isoformat(),
            "version": version,
            "is_a_backup": backup
        }
        self._logging.info("Writing {}{}".format(filename, extra_log_info))
        np.savez_compressed(filename, sound_data=self._sound_data, settings=self._settings, metadata=metadata)
    
    def open(self, filename):
        self._logging.info("Opening {}".format(filename))
        # Load the file
        try:
            data = np.load(filename, allow_pickle=True)
        except FileNotFoundError:
            self._logging.error("The select file does not exist.")

        # Find any metadata and print it
        if "metadata" in data:
            self._logging.info("Metadata found: {}".format(data["metadata"]))

        # Check all required data is present
        if not "sound_data" in data or not "settings" in data:
            self._logging.error("There was an issue opening the file. Either 'sound_data' or 'settings' is missing. Are you sure this is a valid file?")
            return

        # Unpacking tha data part
        self._sound_data = data["sound_data"][()] # Cope with 0d arrays
        self._settings = data["settings"][()]

        # Notify stuff that needs to know
        self._call_to_update_settings()
        self._call_to_update_sound()
    
    def set_settings(self, settings):
        self._settings = settings
        self._call_to_update_settings()
    
    def get_settings(self):
        return self._settings

    def get_sound_data(self):
        return self._sound_data

    def set_sound_data(self, new_data):
        self._sound_data = new_data
        self._call_to_update_sound()

    def clear_data(self):
        self._sound_data = []
        self._call_to_update_sound()

    def register_call_on_update(self, method, call_on_sound_data=True, call_on_settings_data=True):
        """Registers a function to be called when the data is updated

        Args:
            method (function): function / method to call
        """
        if call_on_sound_data:
            self._to_call_on_update_sound.append(method)
        if call_on_settings_data:
            self._to_call_on_update_settings.append(method)
    
    def get_piezo_range(self):
        try:
            piezo_range = range(
                int(self._settings["piezo_duty_min"]),
                int(self._settings["piezo_duty_max"])+1,
                int(self._settings["piezo_duty_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the piezo settings given")
        else:
            return piezo_range
        return None
    
    def get_boost_range(self):
        try:
            boost_range = range(
                int(self._settings["boost_duty_min"]),
                int(self._settings["boost_duty_max"])+1,
                int(self._settings["boost_duty_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the boost settings given")
        else:
            return boost_range
        return None

    def get_midi_range(self):
        try:
            midi_range = range(
                int(self._settings["midi_note_min"]),
                int(self._settings["midi_note_max"])+1,
                int(self._settings["midi_note_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the midi settings given")
        else:
            return midi_range
        return None
    
    def __len__(self):
        return len(self._sound_data)

    def _call_to_update_sound(self):
        for i in self._to_call_on_update_sound:
            i()
    
    def _call_to_update_settings(self):
        for i in self._to_call_on_update_settings:
            i()

class BikeHornInterface():
    BAUD = 38400
    CLOCK = 16000000
    TIMER_1_PRESCALER = 8
    TIMER_2_PRESCALAR = 1
    TIMER_2_TOP = 255
    
    EEPROM_TIMER1_PIECEWISE = 1 # // TODO: Work out bytes and addresses that don't interfere with EEPROM wear leveling 
    EEPROM_TIMER2_PIECEWISE = 82 # // 81 bytes for up to 10 points
    

    def __init__(self, logging, data_manager, audio=None, gui=None):
        self._serial_port = serial.Serial()
        self._logging = logging
        self._data_manager = data_manager
        self._audio = audio
        self.set_gui(gui)

    def set_gui(self, gui=None) -> None:
        self._gui = gui
        if self._gui:
            self._gui.add_to_call_on_exit(self.close_port)
    
    def set_audio(self, audio=None) -> None:
        self._audio = audio

    def set_serial_port(self, port_name):
        """Sets and opens the serial port

        Args:
            port_name (str): The serial port to open
        """
        self.close_port()

        self._serial_port.port = port_name
        self._serial_port.baudrate = BikeHornInterface.BAUD
        self._serial_port.timeout = 60

        # Test the port
        self._logging.info("Testing the serial port - ", end="")
        try:
            self._serial_port.open()
            self._serial_port.close()
        except SerialException:
            msg = "Could not open serial port '{}'".format(port_name)
            self._logging.warning(msg)
        else:
            self._logging.info("Success")
            
    def run_test(self, piezo_duty_values:Iterable, boost_duty_values:Iterable, midi_values:Iterable):
        """Runs the test

        Args:
            piezo_duty_values (Iterable): The values to test for the piezo duty cycle (%)
            boost_duty_Values (Iterable): The values to test for the boost duty cycle (%)
            midi_values (Iterable): The values to test for the midi note (0-127)
        """
        self._abort = False
        sound_data = []
        
        self._start_test()
        if not self._abort:
            # Progress bar
            total_steps = len(piezo_duty_values) * len(boost_duty_values) * len(midi_values)
            self._logging.info("Running the test (when it is implemented) with {} points to test".format(total_steps))
            current_step = 0

            for midi in midi_values:
                sound_midi_data = []
                for boost in boost_duty_values:
                    sound_boost_data = []
                    for piezo in piezo_duty_values:
                        # Progress bar stuff
                        percent_done = current_step / total_steps * 100
                        self._logging.info("MIDI Note: {}, Piezo: {}, Boost: {}, {:.1f}% done".format(midi, piezo, boost, percent_done))
                        if self._gui:
                            self._gui.update_test_progress(percent_done)
                        
                        # The actual communicating and testing part
                        sound_boost_data.append(self._get_data_point(midi, boost, piezo))

                        # Other housekeeping
                        current_step += 1
                        if self._abort:
                            self._logging.info("Aborting the test")
                            self._shutdown(False)
                            return

                    sound_midi_data.append(sound_boost_data)
                
                # Let the horn cool off
                self._logging.info("Stopping for a few seconds to let the horn cool off")
                self._shut_up()
                time.sleep(10)

                # Save and make a backup copy of the data
                sound_data.append(sound_midi_data)
                data_manager.set_sound_data(sound_data)
                data_manager.save_data(backup=True)

            # Finished the test successfully
            self._shutdown()
            self._logging.info("Finished the test successfully", True)

    def get_serial_ports(self):
        """Returns a list of serial ports.
        Based off https://stackoverflow.com/a/67519864
        """
        return [i.device for i in serial.tools.list_ports.comports()]
    
    def close_port(self):
        if self._serial_port.isOpen():
            self._logging.info("Closing the serial port")
            self._serial_port.close()
    
    def abort_test(self):
        """Sets the flag to stop testing
        """
        self._abort = True
    
    def midi_to_freq(self, midi):
        # Useful resource for midi note and frequencies: https://newt.phys.unsw.edu.au/jw/notes.html
        assert midi >= 0 and midi <= 127, "Midi out of range 0-127. Was given {}".format(midi)
        return 2**((midi-69)/12) * 440

    def midi_to_counter_top(self, midi):
        return round(BikeHornInterface.CLOCK/BikeHornInterface.TIMER_1_PRESCALER/self.midi_to_freq(midi))

    def duty_to_counter_compare(self, duty, counter_top):
        return round(counter_top * duty / 100)

    def _get_data_point(self, midi, boost, piezo):
        if self._serial_port.isOpen():
            # Write to serial port
            t1_top = self.midi_to_counter_top(midi)
            t1_compare = self.duty_to_counter_compare(piezo, t1_top)
            t2_compare = self.duty_to_counter_compare(boost, BikeHornInterface.TIMER_2_TOP)
            self._serial_port.write("~`~`p{}~{}~{}`~`~".format(t1_top, t1_compare, t2_compare).encode('UTF-8'))
            
            # Wait for acknowledge
            response = self._serial_port.read_until("`~`~".encode('UTF-8'))
            if "~`~`Ack`~`~" not in str(response):
                self._logging.error("Lost connection to horn - no acknowledge received")
                self.abort_test()
                return 0
            
            time.sleep(0.2) # A short while to let things stabilise
            return self._audio.get_level()
        else:
            self._logging.error("Lost connection to horn - serial port closed unexpectedly")
            self.abort_test()


    def _start_test(self):
        self._logging.info("Opening the serial port")
        try:
            self._serial_port.open()
        except SerialException:
            msg = "Could not open serial port"
            self._logging.warning(msg)
            return
        
        if self._serial_port.isOpen():
            response = self._serial_port.read_until("`~`~".encode('UTF-8'))
            print(response)
            if "~`~`Ready`~`~" not in str(response):
                # Failure
                self._logging.error("Did not get a response from the the horn")
                self.abort_test()
        else:
            # Port closed
            self._logging.error("Serial port is closed")
            self.abort_test()
    
    def _shut_up(self, require_response=True):
        if self._serial_port.isOpen():
            self._serial_port.write("~`~`s`~`~".encode('UTF-8'))
        
            # Wait for acknowledge
            if require_response:
                response = self._serial_port.read_until("`~`~".encode('UTF-8'))
                if "~`~`Ack`~`~" not in str(response):
                    self._logging.error("Lost connection to horn - no acknowledge received")
                    self.abort_test()
        elif require_response:
            self._logging.error("Lost connection to horn - serial port closed unexpectedly")
            self.abort_test()

    def _shutdown(self, success=True):
        """Attempts to make the horn go quiet"""
        self._logging.info("Attempted to shut down")
        self._shut_up(False)
        if self._serial_port.isOpen():
            self._logging.info("Closing the serial port")
            try:
                self._serial_port.close()
            except SerialException:
                msg = "Could not close serial port"
                self._logging.warning(msg)
                return
        
        if self._gui:
            self._gui.test_finished(success)

class LinearFunction():
    """Class for a linear function
    """
    MAX_MULTIPLIER = 255
    MAX_DENOMINATOR = 127
    MAX_CONSTANT = 2**31-1

    def __init__(self, gradient, x0, y0):
        self.m = gradient
        self.c = int(round(y0-gradient*x0))
        assert self.c > -(LinearFunction.MAX_CONSTANT - 1) and self.c < LinearFunction.MAX_CONSTANT, "Constant ({}) is the wrong size".format(self.c)
    
    def apply(self, x):
        return self.m * x + self.c

    def to_bytes(self):
        """Returns bytes in the form multiplier, divisor, constant
        """
        numerator, denominator = self._multiplier_as_fraction()
        return numerator.to_bytes(1, "little", signed=False) + denominator.to_bytes(1, 'little', signed=True) + self.c.to_bytes(4, 'little', signed=True)

    def _multiplier_as_fraction(self) -> tuple:
        """Converts the multiplier to a fraction where the numerator is at most MAX_MULTIPLIER

        Returns:
            tuple: The multiplier in the form (numerator, denominator)
        """
        numerator = 0
        denominator = 1
        if self.m != 0:
            m_fraction = fractions.Fraction(self.m)
            max_denominator = min(max(math.floor(LinearFunction.MAX_MULTIPLIER / abs(self.m)), 1), LinearFunction.MAX_DENOMINATOR)
            m_fraction = m_fraction.limit_denominator(max_denominator)
            assert abs(m_fraction.numerator) <= LinearFunction.MAX_MULTIPLIER, "Numerator is too big"
            assert abs(m_fraction.denominator) <= LinearFunction.MAX_MULTIPLIER, "Denominator is too big"
            
            numerator = int(m_fraction.numerator)
            denominator = int(m_fraction.denominator)
            if numerator < 0:
                numerator = -numerator
                denominator = -denominator

        return numerator, denominator


    def __str__(self):
        numerator, denominator = self._multiplier_as_fraction()
        return "{:>5.0f}*x/{:>5.0f} + {:>5.0f}".format(numerator, denominator, self.c)

class PiecewiseLinear():
    """Class for piecewise linear functions"""
    def __init__(self, fit=None, n_breakpoints=None, x_coords=None, y_coords=None):
        """Loads fit data in dictionary form from piecewise linear regression
        Use either fit and n_breakpoints or x_coords and y_coords, not both"""
        self._functions = []
        if fit is not None and n_breakpoints is not None:
            # Generate from fit data dictionary
            def get_est(key):
                return fit["estimates"][key]["estimate"]
            # Sort alphas and breakpoints by breakpoints in fit
            fit_poi = []
            for i in range(1, n_breakpoints+1):
                beta = get_est("beta{}".format(i))
                breakpoint = get_est("breakpoint{}".format(i))
                fit_poi.append((beta, breakpoint))
            fit_poi.sort(key=lambda x: x[1])

            # Generating the functions
            # Function to the left of the first breakpoint
            m = get_est("alpha1")
            c = get_est("const")
            self._functions.append((LinearFunction(m, 0, c), 0)) # The only alpha we can rely on (see https://github.com/chasmani/piecewise-regression/issues/3)
            for i in range(n_breakpoints):
                m += fit_poi[i][0] # Beta
                c -= fit_poi[i][0]*fit_poi[i][1] # Beta * Breakpoint
                self._functions.append((LinearFunction(m, 0, c), fit_poi[i][1]))
        else:
            # Generate from coordinates of the breakpoints and ends
            assert len(x_coords) == len(y_coords), "Mismatch in coordinate length"
            for i in range(1, len(x_coords)):
                m = (y_coords[i] - y_coords[i-1]) / (x_coords[i] - x_coords[i-1])
                self._functions.append((LinearFunction(m, x_coords[i], y_coords[i]), x_coords[i]))
            
            # Sort in case the transform made it out of order
            self._functions.sort(key=lambda x: x[1])
            self._functions[0] = (self._functions[0][0], 0)


    def apply(self, x: float) -> float:
        """Applies the piecewise function to the given number

        Args:
            x (float): Input number

        Returns:
            float: f(x) (i.e. the result)
        """
        return self.function_for_given(x).apply(x)

    def function_for_given(self, x:float) -> LinearFunction:
        """Returns the LinearFunction that would be used for a given number

        Args:
            x (number): The given number

        Returns:
            LinearFunction: The function that would be used when evaluating
        """
        for i in range(len(self._functions)-1):
            if x < self._functions[i+1][1]:
                # Found the corresponding function
                return self._functions[i][0]
        
        # Else clause
        return self._functions[-1][0]

    def to_bytes(self):
        """Generates a bytes object representing the piecewise function in the form
        [uint8_t length,
         uint16_t threshold1, uint8_t multiplier1, int8_t divisor1, init32_t constant1,
         ...,
         uint16_t thresholdn, uint8_t multipliern, int8_t divisorn, init32_t constantn]
        """
        result = len(self).to_bytes(1, 'little', signed=False)
        for function, threshold in self._functions:
            result += int(threshold).to_bytes(2, 'little', signed=False)
            result += function.to_bytes()

        return result
    
    def as_coordinates(self, minimum, maximum) -> Tuple:
        """
        Generates a tuple containing the x and y coordinates of each breakpoint + 1 each end that can be used to plot a graph
        """
        x = [minimum]
        y = [self.apply(minimum)]
        for _, threshold in self._functions:
            if threshold > minimum and threshold < maximum:
                x.append(threshold)
                y.append(self.apply(threshold))
        
        x.append(maximum)
        y.append(self.apply(maximum))
        
        return x, y

    def transform(self, x_transform, y_transform, minimum, maximum):
        """Generates and returns a new piecewise function where the x and y coordinates have been
        transformed in certain ways. Only mathematically equivalent if the transforms are
        linear

        Args:
            x_transform (function): Function that returns a number and accepts the existing x and y coordinates that will return new x coordinates
            y_transform (function): Function that returns a number and accepts the existing x and y coordinates that will return new y coordinates

        Returns:
            PiecewiseLinear: New piecewise linear function with the transform from this one
        """
        x, y = self.as_coordinates(minimum, maximum)
        x_coords = []
        y_coords = []
        for i in range(len(x)):
            x_coords.append(x_transform(x[i], y[i]))
            y_coords.append(y_transform(x[i], y[i]))

        return PiecewiseLinear(fit=None, n_breakpoints=None, x_coords=x_coords, y_coords=y_coords)

    def __len__(self):
        return len(self._functions)

    def __str__(self):
        result = []
        for i in range(len(self._functions)):
            if i == len(self._functions) // 2 - 1:
                # Draw 'f(x) = ' instead of spaces
                result.append("f(x) = {")
            else:
                result.append("       {")
            
            result.append(str(self._functions[i][0]))
            if(i == 0):
                # x < x0
                result.append(",           x <  {:>6.0f}\n".format(self._functions[i+1][1]))
            elif(i != len(self._functions)-1):
                # x0 <= x < x1
                result.append(", {:>6.0f} <= x <  {:>6.0f}\n".format(self._functions[i][1], self._functions[i+1][1]))
            else:
                # x >= x0
                result.append(",           x >= {:>6.0f}".format(self._functions[i][1]))
        return "".join(result)


class Optimiser():
    def __init__(self, logging, data_manager:DataManager, bike_horn:BikeHornInterface, gui=None):
        self._data_manager = data_manager
        self._logging = logging
        self._bike_horn = bike_horn
        self._gui = gui
        self._call_on_recalculate = []
        self._call_on_optimise_success = []
        self._data_manager.register_call_on_update(self._recalculate, True, False)
        self._best_boost_duty = []
        self._best_piezo_duty = []
        self._best_loudness = np.empty(1)
        self._piezo_optimised = None
        self._boost_optimised = None
        self._boost_optimisation_valid = -1
        self._piezo_optimisation_valid = -1
    
    def set_gui(self, gui=None):
        self._gui = gui

    def register_call_on_recalculate(self, method):
        self._call_on_recalculate.append(method)
    
    def register_call_on_optimise_sucess(self, method):
        self._call_on_optimise_success.append(method)
    
    def _recalculate(self):
        self._boost_optimisation_valid = -1
        self._piezo_optimisation_valid = -1

        sound_data = np.array(self._data_manager.get_sound_data())

        # Calculate and display the best coordinates
        self._best_boost_duty = [0] * len(sound_data)
        self._best_piezo_duty = [0] * len(sound_data)
        self._best_loudness = np.empty(len(sound_data))

        boost_range = self._data_manager.get_boost_range()
        piezo_range = self._data_manager.get_piezo_range()
        if boost_range is not None and piezo_range is not None:
            for i in range(len(sound_data)):
                boost_index, piezo_index = np.unravel_index(np.argmax(sound_data[i], axis=None), sound_data[i].shape)
                self._best_boost_duty[i] = boost_range[boost_index]
                self._best_piezo_duty[i] = piezo_range[piezo_index]
                self._best_loudness[i] = sound_data[i, boost_index, piezo_index]

        # Call on recalculate
        for i in self._call_on_recalculate:
            i()
    
    def optimise(self, piezo_breakpoints, boost_breakpoints):
        """Processes the data to get linear functions (time consuming)
        """
        # Test if there is enough data
        if len(self._best_piezo_duty) >= 3 and len(self._best_boost_duty) >= 3:
            midi_notes = list(self._data_manager.get_midi_range())

            # Try the piezo regression if needed
            if self._piezo_optimisation_valid != piezo_breakpoints:
                self._logging.info("Fitting piezo data with {} breakpoints".format(piezo_breakpoints))
                piezo_fit = piecewise_regression.Fit(midi_notes, self._best_piezo_duty, n_breakpoints=piezo_breakpoints)
                piezo_fit_results = piezo_fit.get_results()
                if piezo_fit_results["converged"]:
                    # Piezo was successful.
                    self._piezo_optimised = PiecewiseLinear(piezo_fit_results, piezo_breakpoints)
                    self._piezo_optimisation_valid = piezo_breakpoints
                else:
                    self._piezo_optimisation_valid = -1
                    self._logging.error("The piezo results did not converge with {} breakpoints. Maybe try a different number?".format(piezo_breakpoints))
                    return
            else:
                self._logging.info("Have already optimised the piezo results, so no point doing it again")

            # Try the boost regression if needed
            if self._boost_optimisation_valid != boost_breakpoints:
                self._logging.info("Fitting boost data with {} breakpoints".format(boost_breakpoints))
                boost_fit = piecewise_regression.Fit(midi_notes, self._best_boost_duty, n_breakpoints=boost_breakpoints)
                boost_fit_results = boost_fit.get_results()
                if boost_fit_results["converged"]:
                    # Generate piecewise functions
                    self._boost_optimised = PiecewiseLinear(boost_fit_results, boost_breakpoints)
                    self._boost_optimisation_valid = boost_breakpoints
                else:
                    self._boost_optimisation_valid = -1
                    self._logging.error("The boost results did not converge with {} breakpoints. Maybe try a different number?".format(boost_breakpoints))
                    return
            else:
                self._logging.info("Have already optimised the boost results, so no point doing it again")
        else:
            self._logging.error("Not enough data points to optimise (or no data loaded)")
            self._piezo_optimisation_valid = -1
            self._boost_optimisation_valid = -1
            return
        
        # Success. Call everything that needs to know
        self._logging.info("Finished optimising successfully")
        for i in self._call_on_optimise_success:
            i()
    
    def get_piezo_optimised(self):
        return self._piezo_optimised

    def get_boost_optimised(self):
        return self._boost_optimised
    
    def chosen_coords(self, index):
        """Returns piezo, boost and loudness coordinates for a given index in the data"""
        return self._best_piezo_duty[index], self._best_boost_duty[index], self._best_loudness[index]

    def get_t1_optimised(self):
        x_transform = lambda x, _: self._bike_horn.midi_to_counter_top(x)
        y_transform = lambda x, y: self._bike_horn.duty_to_counter_compare(y, self._bike_horn.midi_to_counter_top(x))
        return self._piezo_optimised.transform(x_transform, y_transform, 23, 127) # 23 is the lowest playable note
    
    def get_t2_optimised(self):
        x_transform = lambda x, _: self._bike_horn.midi_to_counter_top(x)
        y_transform = lambda x, y: self._bike_horn.duty_to_counter_compare(y, 0xFF)
        return self._boost_optimised.transform(x_transform, y_transform, 23, 127)
    
    def get_best_boost(self):
        return self._best_boost_duty

    def get_best_piezo(self):
        return self._best_piezo_duty
    
    def get_best_loudness(self):
        return self._best_loudness
    
    def get_best_t2_compare(self):
        result = []
        for i in self._best_boost_duty:
            result.append(self._bike_horn.duty_to_counter_compare(i, BikeHornInterface.TIMER_2_TOP))

        return result
    
    def get_best_t1_compare(self):
        result = []
        t1_tops = self.get_t1_tops()
        for index, duty in enumerate(self._best_piezo_duty):
            result.append(self._bike_horn.duty_to_counter_compare(duty, t1_tops[index]))

        return result
    
    def get_t1_tops(self):
        midi_range = self._data_manager.get_midi_range()
        return [self._bike_horn.midi_to_counter_top(i) for i in midi_range]

    def is_optimisation_valid(self) -> bool:
        """Returns true if the current optimisation has been done and matches the latest data

        Returns:
            bool: Whether the current optimisation data can be trusted
        """
        return self._boost_optimisation_valid != -1 and self._piezo_optimisation_valid != -1

class GUI():
    def __init__(self, logging, bike_horn:BikeHornInterface, data_manager:DataManager, optimiser:Optimiser):
        """Creates and runs the GUI
        """
        self._logging = logging
        self._bike_horn = bike_horn
        self._data_manager = data_manager
        self._optimiser = optimiser
        self._call_on_exit = []

        self._data_manager.register_call_on_update(self.set_settings, False, True)


    def draw(self):
        """Runs the main loop
        """
        # GUI Setting up
        self._root = tk.Tk(className=name)
        self._root.title(name)
        self._root.tk.call('wm', 'iconphoto', self._root._w, tk.PhotoImage(file='icon.png'))

        # Draw the tabbed layout
        tab_control = ttk.Notebook(self._root)
        run_test_tab = ttk.Frame(tab_control)  
        tab_control.add(run_test_tab, text ='Run test / Serial', )
        save_load_tab = ttk.Frame(tab_control)
        tab_control.add(save_load_tab, text ='Save / Load results')
        view_results_tab = ttk.Frame(tab_control)
        tab_control.add(view_results_tab, text='View results')
        optimisation_tab = ttk.Frame(tab_control)
        tab_control.add(optimisation_tab, text ='Optimisation Settings')
        upload_settings_tab = ttk.Frame(tab_control)
        tab_control.add(upload_settings_tab, text ='View / Upload Optimisations')
        help_tab = ttk.Frame(tab_control)
        tab_control.add(help_tab, text="Help / About")
        tab_control.pack(expand=True, fill ='both')

        # Message output
        ttk.Label(self._root, text="Messages").pack(side=tk.LEFT, padx=10, pady=10)
        messages_frame, self._text_messages = self._draw_scrollable_text(self._root, 5)
        messages_frame.pack(expand=True, fill='x')
        
        # Fill up the tabs (after drawing the monitor so they can log to it)
        self._draw_run_test_tab(run_test_tab)
        self._draw_save_load_tab(save_load_tab)
        self._save_settings()
        self._draw_results_tab(view_results_tab)
        self._draw_optimisation_tab(optimisation_tab)
        self._draw_upload_tab(upload_settings_tab)
        self._draw_help_tab(help_tab)

        self._root.protocol("WM_DELETE_WINDOW", self._close_window)
    
    def run(self):
        # Ready for interaction
        self._root.mainloop()

    def _draw_scrollable_text(self, parent, height=None, disabled=True):
        """Draws a frame containing 

        Args:
            parent ([type]): [description]
            height ([type]): [description]

        Returns:
            tuple(frame, text): Frame and text widget. The frame needs to be drawn with pack or grid to show
        """
        frame = ttk.Frame(parent)
        if height is not None:
            text = tk.Text(frame, height=height, padx=5, pady=5)
        else:
            text = tk.Text(frame, padx=5, pady=5)
        text.pack(side=tk.LEFT, expand=True, fill='x')
        scroll_bar = tk.Scrollbar(frame, orient='vertical', command=text.yview)
        scroll_bar.pack(side=tk.RIGHT, fill='y')
        text['yscrollcommand'] = scroll_bar.set
        if disabled:
            text.configure(state='disabled')
        return frame, text

    def _confirm_run_test(self):
        """Asks whether to run the test as any unsaved results and settings will be lost
        """
        result = tkmb.askyesno("Confirm run test", "Are you sure you want to run a NEW test? Any previous, unsaved results will be lost.")
        if result:
            try:
                # +1 as people would expect top value to be included
                piezo_range = range(int(self._piezo_duty_min_text.get()), int(self._piezo_duty_max_text.get())+1, int(self._piezo_duty_inc_text.get()))
                boost_range = range(int(self._boost_duty_min_text.get()), int(self._boost_duty_max_text.get())+1, int(self._boost_duty_inc_text.get()))
                midi_range = range(int(self._midi_min_text.get()), int(self._midi_max_text.get())+1, int(self._midi_inc_text.get()))
            except ValueError:
                self._logging.error("Error interpreting test parameters as integers")
            else:
                self._save_settings()
                self._bike_horn.set_serial_port(self._serial_port.get())
                test_thread = threading.Thread(target=self._bike_horn.run_test, args=(piezo_range, boost_range, midi_range), daemon=True)
                test_thread.start()
                self._test_control_button['text'] = "ABORT Test"
                self._test_control_button['command'] = self._confirm_abort_test
                # TODO: Grey out settings
    
    def _confirm_abort_test(self):
        """Confirms the user is sure they want to abort the test"""
        result = tkmb.askokcancel("Abort the test", "Are you sure you can to abort the test? Any results up until the current note can be saved later")
        if result:
            self._bike_horn.abort_test()
    
    def test_finished(self, success):
        self._test_control_button['text'] = "Start Test"
        self._test_control_button['command'] = self._confirm_run_test

        # Set the progress bar to 0 if note successful or make sure it is at the end if success
        if success:
            self.update_test_progress(1)
        else:
            self.update_test_progress(0)

    def update_test_progress(self, value):
        self._root.update_idletasks()
        self._test_progress['value'] = value
    
    def info_dialog(self, msg=""):
        tkmb.showinfo("Info", msg)

    def warning_dialog(self, msg=""):
        tkmb.showwarning("Warning", msg)
    
    def error_dialog(self, msg=""):
        tkmb.showerror("Error", msg)

    def add_monitor_text(self, msg="", end="\n"):
        fully_scrolled_down = self._text_messages.yview()[1] == 1.0 # Scrolling based off https://stackoverflow.com/a/51781603
        self._text_messages.configure(state='normal')
        self._text_messages.insert('end', "{}{}".format(msg,end))
        self._text_messages.configure(state='disabled')
        if fully_scrolled_down:
            self._text_messages.see("end")

    def set_sound_level(self, level):
        try:
            self._root.update_idletasks()
            self._sound_progress['value'] = level
        except RuntimeError:
            print("RuntimeError when setting the sound level, possibly due to an interrupt. Stopping the audio")
            raise sd.CallbackAbort()

    def add_to_call_on_exit(self, method):
        """Adds a method that will be called when the gui window is closed

        Args:
            method (method): Method to call
        """
        self._call_on_exit.append(method)

    def set_settings(self):
        """Sets the settings
        """
        settings = self._data_manager.get_settings()
        self._logging.info("Restoring the settings")
        try:
            self._serial_port.set(settings["serial_port"])
            self._piezo_duty_min_text.set(settings["piezo_duty_min"])
            self._piezo_duty_max_text.set(settings["piezo_duty_max"])
            self._piezo_duty_inc_text.set(settings["piezo_duty_inc"])
            self._boost_duty_min_text.set(settings["boost_duty_min"])
            self._boost_duty_max_text.set(settings["boost_duty_max"])
            self._boost_duty_inc_text.set(settings["boost_duty_inc"])
            self._midi_min_text.set(settings["midi_note_min"])
            self._midi_max_text.set(settings["midi_note_max"])
            self._midi_inc_text.set(settings["midi_note_inc"])
        except KeyError:
            self._logging.warning("A key could not be found when restoring settings")
    
    def _save_settings(self):
        """Saves the settings"""
        try:
            settings = {
                "serial_port": self._serial_port.get(),
                "piezo_duty_min": int(self._piezo_duty_min_text.get()),
                "piezo_duty_max": int(self._piezo_duty_max_text.get()),
                "piezo_duty_inc": int(self._piezo_duty_inc_text.get()),
                "boost_duty_min": int(self._boost_duty_min_text.get()),
                "boost_duty_max": int(self._boost_duty_max_text.get()),
                "boost_duty_inc": int(self._boost_duty_inc_text.get()),
                "midi_note_min": int(self._midi_min_text.get()),
                "midi_note_max": int(self._midi_max_text.get()),
                "midi_note_inc": int(self._midi_inc_text.get()),
            }
        except ValueError:
            self._logging.error("Could not save the current settings - are all numbers proper integers?")
        else:
            self._data_manager.set_settings(settings)

    def _draw_run_test_tab(self, tab):
        # Serial port
        def update_serial_ports():
            ports = self._bike_horn.get_serial_ports()
            self._logging.info("Serial ports found: {}".format(ports))
            if len(ports) == 0:
                ports.append("No serial ports found")
                self._test_control_button["state"] = tk.DISABLED
            else:
                self._test_control_button["state"] = tk.NORMAL
            self._serial_port_dropdown.set_menu(*ports)

        self._serial_port = tk.StringVar(self._root)
        audio_serial_frame = tk.Frame(tab)
        ttk.Label(audio_serial_frame, text="Serial port:").grid(row=0, column=0, padx=10, pady=10, sticky=tk.E)
        self._serial_port_dropdown = ttk.OptionMenu(audio_serial_frame, self._serial_port)
        self._serial_port_dropdown.grid(column=1, row=0, padx=10, pady=10, sticky=tk.EW)
        tk.Button(audio_serial_frame, text="Refresh", command=update_serial_ports).grid(row=0, column=2, padx=10, pady=10)

        # Sound device
        ttk.Label(audio_serial_frame, text="Audio level (preview):").grid(row=1, column=0, padx=10, pady=10, sticky=tk.E)
        self._sound_progress = ttk.Progressbar(audio_serial_frame, orient=tk.HORIZONTAL, mode='determinate')
        self._sound_progress.grid(column=1, row=1, columnspan=2, sticky=tk.NSEW, padx=10, pady=10)

        audio_serial_frame.columnconfigure(1, weight=1)
        audio_serial_frame.grid(row=0, column=0, columnspan=6, sticky=tk.NSEW)

        # Sweep settings
        # Piezo
        ttk.Label(tab, text="Piezo duty min (%):").grid(row=1, padx=10, pady=10, sticky=tk.E)
        self._piezo_duty_min_text = tk.StringVar(value=5)
        piezo_duty_min_spinbox = ttk.Spinbox(tab, from_=0, to=100, textvariable=self._piezo_duty_min_text, width=5)
        piezo_duty_min_spinbox.grid(row=1, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Piezo duty max (%):").grid(row=1, column=2, padx=10, pady=10, sticky=tk.E)
        self._piezo_duty_max_text = tk.StringVar(value=75)
        piezo_duty_max_spinbox = ttk.Spinbox(tab, from_=0, to=100, textvariable=self._piezo_duty_max_text, width=5)
        piezo_duty_max_spinbox.grid(row=1, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Piezo duty increment (%):").grid(row=1, column=4, padx=10, pady=10, sticky=tk.E)
        self._piezo_duty_inc_text = tk.StringVar(value=5)
        piezo_duty_inc_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._piezo_duty_inc_text, width=5)
        piezo_duty_inc_spinbox.grid(row=1, column=5, padx=10, pady=10, sticky=tk.W)

        # Boost
        ttk.Label(tab, text="Boost duty min (%):").grid(row=2, padx=10, pady=10, sticky=tk.E)
        self._boost_duty_min_text = tk.StringVar(value=40)
        boost_duty_min_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._boost_duty_min_text, width=5)
        boost_duty_min_spinbox.grid(row=2, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Boost duty max (%):").grid(row=2, column=2, padx=10, pady=10, sticky=tk.E)
        self._boost_duty_max_text = tk.StringVar(value=90)
        boost_duty_max_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._boost_duty_max_text, width=5)
        boost_duty_max_spinbox.grid(row=2, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Boost duty increment (%):").grid(row=2, column=4, padx=10, pady=10, sticky=tk.E)
        self._boost_duty_inc_text = tk.StringVar(value=5)
        boost_duty_inc_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._boost_duty_inc_text, width=5)
        boost_duty_inc_spinbox.grid(row=2, column=5, padx=10, pady=10, sticky=tk.W)

        # MIDI
        ttk.Label(tab, text="MIDI note min:").grid(row=3, padx=10, pady=10, sticky=tk.E)
        self._midi_min_text = tk.StringVar(value=20)
        midi_min_spinbox = ttk.Spinbox(tab,  from_=0, to=127, textvariable=self._midi_min_text, width=5)
        midi_min_spinbox.grid(row=3, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="MIDI note max:").grid(row=3, column=2, padx=10, pady=10, sticky=tk.E)
        self._midi_max_text = tk.StringVar(value=127)
        midi_max_spinbox = ttk.Spinbox(tab,  from_=0, to=127, textvariable=self._midi_max_text, width=5)
        midi_max_spinbox.grid(row=3, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="MIDI note increment:").grid(row=3, column=4, padx=10, pady=10, sticky=tk.E)
        self._midi_inc_text = tk.StringVar(value=5)
        midi_inc_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._midi_inc_text, width=5)
        midi_inc_spinbox.grid(row=3, column=5, padx=10, pady=10, sticky=tk.W)

        # Run test and progress bar
        self._test_control_button = ttk.Button(tab, text="Start test", command=self._confirm_run_test)
        self._test_control_button.grid(row=4, padx=10, pady=10, columnspan=6, sticky=tk.NSEW)

        self._test_progress = ttk.Progressbar(tab, orient=tk.HORIZONTAL, mode='determinate', length=800)
        self._test_progress.grid(column=0, row=5, columnspan=6, sticky=tk.NSEW, padx=10, pady=10)

        update_serial_ports()
        tab.columnconfigure(tuple(range(6)), weight=1)

    def _draw_save_load_tab(self, tab):
        ttk.Label(tab, text="Current file:").grid(row=0, column=0, sticky=tk.W, padx=10, pady=10)
        self._current_file_text = tk.Text(tab, height=2, padx=5, pady=5)
        self._current_file_text.grid(row=0, column=1, sticky=tk.NSEW, padx=10, pady=10)
        self._replace_text_contents(self._current_file_text, self._data_manager.get_filename())
        ttk.Button(tab, text="Open", command=self._select_open_file).grid(row=0, column=3, padx=10, pady=10, sticky=tk.E)
        ttk.Button(tab, text="Save as", command=self._select_save_file).grid(row=0, column=4, padx=10, pady=10, sticky=tk.E)

        tab.columnconfigure(1, weight=2)
        # TODO: Show metadata and settings - possibly in a text box

    def _draw_results_tab(self, tab):
        self._results_fig = Figure()
        # Based of various examples
        self._results_cur_value = 0
        # Call on optimiser as we are now showing a dot for the chosen position
        self._optimiser.register_call_on_recalculate(self._plot_results)
        self._optimiser.register_call_on_recalculate(self._update_results_scroll)

        # Based off https://www.geeksforgeeks.org/how-to-embed-matplotlib-charts-in-tkinter-gui/
        # Create the Tkinter canvas containing the Matplotlib figure
        canvas = FigureCanvasTkAgg(self._results_fig, tab)
        canvas.draw()
        # Need to set axis after setting canvass
        self._ax_loudness = self._results_fig.gca(projection='3d')
        self._results_fig.suptitle("Run a test or import some data to get started")
        canvas.get_tk_widget().pack()

        # Scroll bar
        self._results_scrollbar = ttk.Scrollbar(tab, orient='horizontal', command=self._plot_results_scroll)
        self._results_scrollbar.pack(fill='x')
        
        # Create the Matplotlib toolbar
        toolbar = NavigationToolbar2Tk(canvas, tab)
        toolbar.update()
    
    def _draw_optimisation_tab(self, tab):
        # GUI Variables
        self._optimiser_show_counters = tk.IntVar()
        self._optimiser_piezo_breakpoints_text = tk.StringVar(value=4)
        self._optimiser_boost_breakpoints_text = tk.StringVar(value=3)

        # Graphs
        self._optimiser_fig = Figure()
        self._optimiser_fig.suptitle("Parameters for best performance of each note")
        self._ax_boost_best = self._optimiser_fig.add_subplot(2, 1, 1)
        self._ax_piezo_best = self._optimiser_fig.add_subplot(2, 1, 2)
        self._plot_optimisation()
        self._optimiser_fig.subplots_adjust(hspace=0.5)
        canvas = FigureCanvasTkAgg(self._optimiser_fig, tab)
        canvas.draw()
        canvas.get_tk_widget().pack()

        # Settings down the bottom
        settings_frame = tk.Frame(tab)
        tk.Checkbutton(settings_frame, text="Show timer values", variable=self._optimiser_show_counters, command=self._plot_optimisation).grid(row=0, column=0, sticky=tk.W, padx=10, pady=10)
        tk.Label(settings_frame, text="Boost breakpoints:").grid(row=0, column=1, sticky=tk.E, padx=10, pady=10)
        ttk.Spinbox(settings_frame,  from_=1, to=10, textvariable=self._optimiser_boost_breakpoints_text, width=10).grid(row=0, column=2, sticky=tk.W, padx=10, pady=10)
        tk.Label(settings_frame, text="Piezo breakpoints:").grid(row=0, column=3, sticky=tk.E, padx=10, pady=10)
        ttk.Spinbox(settings_frame,  from_=1, to=10, textvariable=self._optimiser_piezo_breakpoints_text, width=10).grid(row=0, column=4, sticky=tk.W, padx=10, pady=10)
        self._optimise_button = tk.Button(settings_frame, text="Optimise", command=self._start_optimise)
        self._optimise_button.grid(row=0, column=5, sticky=tk.E, padx=10, pady=10)
        settings_frame.columnconfigure(tuple(range(6)), weight=1)
        settings_frame.pack(expand=True, fill='x')

        # Create the Matplotlib toolbar
        toolbar = NavigationToolbar2Tk(canvas, tab)
        toolbar.update()
        self._optimiser.register_call_on_recalculate(self._plot_optimisation)
        self._optimiser.register_call_on_optimise_sucess(self._plot_optimisation)

    def _draw_help_tab(self, tab):
        ttk.Label(tab, text="{} version {}".format(name, version), font=("", 15, "bold")).grid(padx=10, pady=(10, 0), sticky=tk.W)
        ttk.Label(tab, text=
"""By Jotham Gates
This is still a work in progress. For more info, go to:""").grid(padx=10, pady=(10, 0), sticky=tk.W)
        # Link based off https://stackoverflow.com/a/23482749
        github = "https://github.com/jgOhYeah/BikeHorn"
        github_link = ttk.Label(tab, text=github, cursor="hand2", foreground="blue")
        github_link.grid(padx=10, pady=(0, 10), sticky=tk.W)
        github_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab(github))
        ttk.Label(tab, text="Main Steps:", font=("", 12, "bold")).grid(padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text=
"""1. Upload the optimising sketch to the horn.
2. Run or open a test.
3. Adjust settings for and optimise the data in the 'Optimisation settings' tab.
4. Upload the optimised settings to the horn.
5. Upload the main bike horn sketch to put the horn back in power saving mode.""").grid(padx=10, pady=10, sticky=tk.W)
    
    def _draw_upload_tab(self, tab):
        ttk.Label(tab, text="Optimal timer 1 (piezo) compare as a function of timer 1 top").grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)
        frame, self._timer1_human_readable = self._draw_scrollable_text(tab, 4)
        frame.grid(row=1, sticky=tk.NSEW, padx=10, pady=(0, 10))
        ttk.Label(tab, text="Optimal timer 2 (boost) compare as a function of timer 1 top").grid(row=2, column=0, padx=10, pady=10, sticky=tk.W)
        frame, self._timer2_human_readable = self._draw_scrollable_text(tab, 4)
        frame.grid(row=3, sticky=tk.NSEW, padx=10, pady=(0, 10))
        ttk.Label(tab, text="Compiled settings that will be uploaded").grid(row=4, column=0, padx=10, pady=10, sticky=tk.NSEW)
        frame, self._to_upload_text = self._draw_scrollable_text(tab, 5)
        frame.grid(row=5, sticky=tk.NSEW, padx=10, pady=(0, 10))
        self._upload_button = ttk.Button(tab, text="Upload to horn (WHEN IMPLEMENTED)")
        self._upload_button.grid(row=6, column=0, padx=10, pady=10, sticky=tk.NSEW)
        self._upload_button["state"] = tk.DISABLED

        self._draw_optimised_formulas()
        self._optimiser.register_call_on_recalculate(self._draw_optimised_formulas)
        self._optimiser.register_call_on_optimise_sucess(self._draw_optimised_formulas)
        tab.columnconfigure(0, weight=1)
        tab.rowconfigure((1, 3, 5), weight=1)

    def _draw_optimised_formulas(self):
        """Fills the text boxes with formulas
        """
        def hex_list(lst):
            result = ["["]
            for i in lst:
                if len(result) != 1:
                    result.append(", ")
                result.append("0x{:0>2x}".format(i))
            result.append("]")
            return "".join(result)

        if self._optimiser.is_optimisation_valid():
            # Sucess, draw the formulas
            timer1_contents = str(self._optimiser.get_t1_optimised())
            timer2_contents = str(self._optimiser.get_t2_optimised())
            self._replace_text_contents(self._timer1_human_readable, timer1_contents)
            self._replace_text_contents(self._timer2_human_readable, timer2_contents)
            t1_list = list(self._optimiser.get_t1_optimised().to_bytes())
            t2_list = list(self._optimiser.get_t2_optimised().to_bytes())
            compiled_contents = """Starting from EEPROM address {} using {} bytes:
{}

Starting from EEPROM address {} using {} bytes:
{}""".format(BikeHornInterface.EEPROM_TIMER1_PIECEWISE, len(t1_list), hex_list(t1_list),
             BikeHornInterface.EEPROM_TIMER2_PIECEWISE, len(t2_list), hex_list(t2_list))
            self._replace_text_contents(self._to_upload_text, compiled_contents)
        else:
            # No success
            self._replace_text_contents(self._timer1_human_readable, "Click 'Optimise' on the 'Optimisation Settings' tab to generate this")
            self._replace_text_contents(self._timer2_human_readable, "Click 'Optimise' on the 'Optimisation Settings' tab to generate this")
            self._replace_text_contents(self._to_upload_text, "Click 'Optimise' on the 'Optimisation Settings' tab to generate this")

    def _start_optimise(self):
        """Starts the optimising process"""
        def run_optimise(piezo_breakpoints, boost_breakpoints):
            """Runs the optimising process and controls the button"""
            self._optimise_button["state"] = tk.DISABLED
            self._optimiser.optimise(piezo_breakpoints, boost_breakpoints)
            self._optimise_button["state"] = tk.NORMAL
        try:
            piezo_breakpoints = int(self._optimiser_piezo_breakpoints_text.get())
            boost_breakpoints = int(self._optimiser_boost_breakpoints_text.get())
        except ValueError:
            self._logging.error("Error interpreting optimisation parameters as integers")
        else:
            self._logging.info("Starting optimising process. This may take a few seconds")
            test_thread = threading.Thread(target=run_optimise, args=(piezo_breakpoints, boost_breakpoints), daemon=True)
            test_thread.start()


    def _plot_optimisation(self):
        self._ax_boost_best.clear()
        self._ax_piezo_best.clear()
        boost_x, boost_y = ([], [])
        piezo_x, piezo_y = ([], [])

        if self._optimiser_show_counters.get():
            # Show counters instead of %
            self._ax_boost_best.set_title("Optimal boost (timer 2) compare value")
            self._ax_boost_best.set_xlabel("Piezo (timer 1) top")
            self._ax_boost_best.set_ylabel("Timer 2 compare")
            self._ax_piezo_best.set_title("Optimal piezo (timer 1) compare value")
            self._ax_piezo_best.set_xlabel("Piezo (timer 1) top")
            self._ax_piezo_best.set_ylabel("Timer 1 compare")

            midi = self._optimiser.get_t1_tops()[:len(self._data_manager)]
            best_boost = self._optimiser.get_best_t2_compare()
            best_piezo = self._optimiser.get_best_t1_compare()

            if self._optimiser.is_optimisation_valid():
                boost_x, boost_y = self._optimiser.get_t1_optimised().as_coordinates(midi[0], midi[-1])
                piezo_x, piezo_y = self._optimiser.get_t2_optimised().as_coordinates(midi[0], midi[-1])
        else:
            # Show %
            self._ax_boost_best.set_title("Optimal boost duty cycle")
            self._ax_boost_best.set_xlabel("MIDI Note")
            self._ax_boost_best.set_ylabel("Boost duty cycle [%]")
            self._ax_piezo_best.set_title("Optimal piezo duty cycle")
            self._ax_piezo_best.set_xlabel("MIDI Note")
            self._ax_piezo_best.set_ylabel("Piezo duty cycle [%]")
            midi = self._data_manager.get_midi_range()[:len(self._data_manager)]
            best_boost = self._optimiser.get_best_boost()
            best_piezo = self._optimiser.get_best_piezo()

            if self._optimiser.is_optimisation_valid():
                boost_x, boost_y = self._optimiser.get_boost_optimised().as_coordinates(midi[0], midi[-1])
                piezo_x, piezo_y = self._optimiser.get_piezo_optimised().as_coordinates(midi[0], midi[-1])
        
        self._ax_boost_best.plot(midi, best_boost, label="Measured")
        self._ax_piezo_best.plot(midi, best_piezo, label="Measured")

        if self._optimiser.is_optimisation_valid():
            self._ax_boost_best.plot(boost_x, boost_y, label="Optimised")
            self._ax_piezo_best.plot(piezo_x, piezo_y, label="Optimised")

        self._ax_boost_best.legend()
        self._ax_piezo_best.legend()

        self._optimiser_fig.canvas.draw_idle()

    def _plot_results_scroll(self, instruction=None, amount=None, units=None):
        max_index = len(self._data_manager.get_sound_data())-1
        if instruction == tk.SCROLL:
            amount = int(amount)
            # Move one unit at a time (clicking on arrows at ends)
            if amount > 0 and self._results_cur_value < max_index:
                self._plot_results(self._results_cur_value + 1)
            if amount < 0 and self._results_cur_value > 0:
                self._plot_results(self._results_cur_value - 1)
            self._update_results_scroll()

        elif instruction == tk.MOVETO:
            # Convert float to an index
            amount = float(amount)
            max_index = len(self._data_manager.get_sound_data())-1
            amount = max(min(round(max_index*amount) / max_index, 1), 0)
            self._update_results_scroll(amount)
            if max_index >= 0:
                self._plot_results(max_index*amount)
    
    def _update_results_scroll(self, position=None):
        width = 1/max(len(self._data_manager.get_sound_data())-1, 1)
        if position is None:
            position = self._results_cur_value * width
        operating_range = 1-width
        left = min(max(position * operating_range, 0), operating_range)
        right = left + width
        self._results_scrollbar.set(left, right)

    def _plot_results(self, val=None):
        # Index to search for
        sound_data = np.array(self._data_manager.get_sound_data())
        if val is not None:
            val = int(val)
        else:
            # Not specified, if not on the last one, stay the same, otherwise go to latest
            if self._results_cur_value < len(sound_data)-2:
                val = self._results_cur_value
            else:
                val = len(sound_data)-1
        
        self._results_cur_value = val
        
        # Getting data and plotting it
        piezo_range = self._data_manager.get_piezo_range()
        if piezo_range:
            boost_range = self._data_manager.get_boost_range()
            if boost_range:
                piezo_mesh, boost_mesh = np.meshgrid(piezo_range, boost_range)

                # Update the title
                self._results_fig.suptitle("Performance for midi note {}".format(self._data_manager.get_midi_range()[val]))

                # Process data and get the maximum and minimum
                sound_data = np.array(self._data_manager.get_sound_data())
                loudness = sound_data[val]

                # Display subplot 1
                self._ax_loudness.cla()
                self._ax_loudness.set_xlabel("Piezo Duty Cycle [%]")
                self._ax_loudness.set_ylabel("Boost Duty Cycle [%]")
                self._ax_loudness.set_zlabel("Loudness")
                self._ax_loudness.plot_surface(piezo_mesh, boost_mesh, loudness, color="b")
                best_piezo, best_boost, best_loudness = self._optimiser.chosen_coords(val)
                best_path = self._ax_loudness.scatter([best_piezo], [best_boost], [best_loudness], marker="o", color="r")
                best_path.set_sizes([20])
                self._ax_loudness.set_xlim3d(piezo_mesh[0,0], piezo_mesh[-1,-1])
                self._ax_loudness.set_ylim3d(boost_mesh[0,0], boost_mesh[-1,-1])
                custom_legend = [Patch(facecolor='blue', edgecolor='blue', label='Measured'),
                                 Line2D([0], [0], marker='o', color='w', label='Best (Chosen)', markerfacecolor='r', markersize=8)]
                self._ax_loudness.legend(handles=custom_legend)

                # Update
                self._results_fig.canvas.draw_idle()

    def _replace_text_contents(self, widget, text):
        widget.configure(state='normal')
        widget.delete('1.0', 'end')
        widget.insert('end', text)
        widget.configure(state='disabled')

    def _select_save_file(self):
        self._data_manager.get_filename()
        filename = fd.asksaveasfilename(defaultextension="npz", initialfile=self._data_manager.get_filename())
        if type(filename) == str:
            self._logging.info("Filename to use is: '{}'".format(filename))
            self._replace_text_contents(self._current_file_text, filename)
            self._data_manager.set_filename(filename)
            self._save_settings()
            self._data_manager.save_data()
        else:
            self._logging.info("Cancelled saving file")
    
    def _select_open_file(self):
        result = tkmb.askyesno("Open an existing file", "Are you sure you want to open an existing file? Any unsaved data will be lost.")
        if result:
            filename = fd.askopenfilename(defaultextension="npz", initialfile=self._data_manager.get_filename())
            if type(filename) == str and filename != "":
                self._data_manager.open(filename)
                self._replace_text_contents(self._current_file_text, filename)
            else:
                self._logging.info("Cancelled opening file")
        else:
            self._logging.info("Cancelled opening file")


    def _close_window(self):
        """Calls everything this is meant to call before closing, then destroys the window
        """
        self._logging.info("Closing")
        for i in self._call_on_exit:
            i()
        
        # Dodgy bit to make stuff close in the right order
        self._root.destroy()

class Logging():
    """Class for logging events and displaying them in appropriate locations
    """
    def __init__(self, gui:GUI=None) -> None:
        self._gui = gui

    def set_gui(self, gui=None) -> None:
        self._gui = gui

    def info(self, msg="", end="\n", dialog=False) -> None:
        print(msg)
        if self._gui:
            self._gui.add_monitor_text(msg, end)
            if dialog:
                self._gui.info_dialog(msg)

    def warning(self, msg="") -> None:
        warning_msg = "WARNING: {}".format(msg)
        print(warning_msg)
        if self._gui:
            self._gui.add_monitor_text(warning_msg)
            # self.gui.warning_dialog(msg)
    
    def error(self, msg="") -> None:
        error_msg = "ERROR: {}".format(msg)
        print(error_msg)
        if self._gui:
            self._gui.add_monitor_text(error_msg)
            self._gui.error_dialog(msg)

class AudioLevels():
    def __init__(self, gui:GUI=None):
        self._audio_level = 0
        self._stream = sd.InputStream(callback=self._audio_callback, blocksize=500)
        self.set_gui(gui)
        self._stop_required = False

    def set_gui(self, gui=None) -> None:
        self._gui = gui
        if self._gui:
            self._gui.add_to_call_on_exit(self.stop)

    def start(self):
        self._stop_required = False
        self._stream.start()

    def stop(self):
        # Make stopping part of the callback as otherwise it seems to lock up occasionally
        print("Audio stop required")
        self._stop_required = True

        # Wait until we know it stops
        while self._stop_required:
            time.sleep(0.1)
    
    def get_level(self):
        return self._audio_level

    def _audio_callback(self, indata, frames, time, status):
        if self._stop_required:
            print("Stopping audio")
            self._stop_required = False
            raise sd.CallbackAbort()
        
        self._audio_level = np.linalg.norm(indata) * 10
        if self._gui:
            self._gui.set_sound_level(self._audio_level)

if __name__ == "__main__":
    logging = Logging()
    data_manager = DataManager(logging)
    bike_horn = BikeHornInterface(logging, data_manager)
    optimiser = Optimiser(logging, data_manager, bike_horn)
    gui = GUI(logging, bike_horn, data_manager, optimiser)
    optimiser.set_gui(gui)
    bike_horn.set_gui(gui)
    audio = AudioLevels(gui)
    bike_horn.set_audio(audio)
    logging.set_gui(gui)
    gui.draw()
    audio.start()
    gui.run()