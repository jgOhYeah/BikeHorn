#!/usr/bin/env python3
# GUI libraries
import tkinter as tk                    
from tkinter import ttk
from tkinter import filedialog as fd
from tkinter.constants import NSEW
import tkinter.messagebox as tkmb
import webbrowser

# Graphs
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from numpy.lib.shape_base import _put_along_axis_dispatcher

# Serial
import serial.tools.list_ports
from serial.serialutil import SerialException
import serial

# Sound
import sounddevice as sd

# Optimising
import piecewise_regression

# General
import time
import numpy as np
import threading
from typing import Iterable
import datetime

import faulthandler; faulthandler.enable() # TODO: Remove when segmentation fault is found

# TODO: Load / save a default settings file automatically (not necessary, but might be convenient)

version = "0.0.1a"

class DataManager():
    """Class to handle all data and the loading and saving of it
    """
    def __init__(self, logging):
        self._filename = datetime.datetime.now().strftime("%Y%m_%H%M_BikeHornTest.npz")
        self._logging = logging
        self._to_call_on_update_sound = []
        self._to_call_on_update_settings = []
        self._settings = {}
        self._sound_data = []

    def get_filename(self):
        """Gets the filename for the current file (or an autogenerated one if not set)

        Returns:
            str: filename
        """
        return self._filename

    def set_filename(self, filename):
        """Sets the filename to use

        Args:
            filename (str): the filename to use
        """
        self._filename = filename
    
    def save_data(self, backup=False):
        """Writes the file containing the data
        """
        filename = self.get_filename()
        extra_log_info = ""
        if backup:
            filename = ".BACKUP_{}".format(filename)
            extra_log_info = " (as a backup)"

        metadata = {
            "date_time": datetime.datetime.now().isoformat(),
            "version": version,
            "is_a_backup": backup
        }
        self._logging.info("Writing {}{}".format(filename, extra_log_info))
        np.savez_compressed(filename, sound_data=self._sound_data, settings=self._settings, metadata=metadata)
    
    def open(self, filename):
        self._logging.info("Opening {}".format(filename))
        # Load the file
        try:
            data = np.load(filename, allow_pickle=True)
        except FileNotFoundError:
            self._logging.error("The select file does not exist.")

        # Find any metadata and print it
        if "metadata" in data:
            self._logging.info("Metadata found: {}".format(data["metadata"]))

        # Check all required data is present
        if not "sound_data" in data or not "settings" in data:
            self._logging.error("There was an issue opening the file. Either 'sound_data' or 'settings' is missing. Are you sure this is a valid file?")
            return

        # Unpacking tha data part
        self._sound_data = data["sound_data"][()] # Cope with 0d arrays
        self._settings = data["settings"][()]

        # Notify stuff that needs to know
        self._call_to_update_settings()
        self._call_to_update_sound()
    
    def set_settings(self, settings):
        self._settings = settings
        self._call_to_update_settings()
    
    def get_settings(self):
        return self._settings

    def get_sound_data(self):
        return self._sound_data

    def set_sound_data(self, new_data):
        self._sound_data = new_data
        self._call_to_update_sound()

    def clear_data(self):
        self._sound_data = []
        self._call_to_update_sound()

    def register_call_on_update(self, method, call_on_sound_data=True, call_on_settings_data=True):
        """Registers a function to be called when the data is updated

        Args:
            method (function): function / method to call
        """
        if call_on_sound_data:
            self._to_call_on_update_sound.append(method)
        if call_on_settings_data:
            self._to_call_on_update_settings.append(method)
    
    def get_piezo_range(self):
        try:
            piezo_range = range(
                int(self._settings["piezo_duty_min"]),
                int(self._settings["piezo_duty_max"])+1,
                int(self._settings["piezo_duty_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the piezo settings given")
        else:
            return piezo_range
        return None
    
    def get_boost_range(self):
        try:
            boost_range = range(
                int(self._settings["boost_duty_min"]),
                int(self._settings["boost_duty_max"])+1,
                int(self._settings["boost_duty_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the boost settings given")
        else:
            return boost_range
        return None

    def get_midi_range(self):
        try:
            midi_range = range(
                int(self._settings["midi_note_min"]),
                int(self._settings["midi_note_max"])+1,
                int(self._settings["midi_note_inc"])
            )
        except (KeyError, ValueError):
            self._logging.error("Error during processing - cannot use the midi settings given")
        else:
            return midi_range
        return None
    
    def __len__(self):
        return len(self._sound_data)

    def _call_to_update_sound(self):
        for i in self._to_call_on_update_sound:
            i()
    
    def _call_to_update_settings(self):
        for i in self._to_call_on_update_settings:
            i()

class BikeHornInterface():
    BAUD = 38400
    CLOCK = 16000000
    TIMER_1_PRESCALER = 8
    TIMER_2_PRESCALAR = 1
    TIMER_2_TOP = 255
    

    def __init__(self, logging, data_manager, audio=None, gui=None):
        self._serial_port = serial.Serial()
        self._logging = logging
        self._data_manager = data_manager
        self._audio = audio
        self.set_gui(gui)

    def set_gui(self, gui=None) -> None:
        self._gui = gui
        if self._gui:
            self._gui.add_to_call_on_exit(self.close_port)
    
    def set_audio(self, audio=None) -> None:
        self._audio = audio

    def set_serial_port(self, port_name):
        """Sets and opens the serial port

        Args:
            port_name (str): The serial port to open
        """
        self.close_port()

        self._serial_port.port = port_name
        self._serial_port.baudrate = BikeHornInterface.BAUD
        self._serial_port.timeout = 60

        # Test the port
        self._logging.info("Testing the serial port - ", end="")
        try:
            self._serial_port.open()
            self._serial_port.close()
        except SerialException:
            msg = "Could not open serial port '{}'".format(port_name)
            self._logging.warning(msg)
        else:
            self._logging.info("Success")
            
    def run_test(self, piezo_duty_values:Iterable, boost_duty_values:Iterable, midi_values:Iterable):
        """Runs the test

        Args:
            piezo_duty_values (Iterable): The values to test for the piezo duty cycle (%)
            boost_duty_Values (Iterable): The values to test for the boost duty cycle (%)
            midi_values (Iterable): The values to test for the midi note (0-127)
        """
        self._abort = False
        sound_data = []
        
        self._start_test()
        if not self._abort:
            # Progress bar
            total_steps = len(piezo_duty_values) * len(boost_duty_values) * len(midi_values)
            self._logging.info("Running the test (when it is implemented) with {} points to test".format(total_steps))
            current_step = 0

            for midi in midi_values:
                sound_midi_data = []
                for boost in boost_duty_values:
                    sound_boost_data = []
                    for piezo in piezo_duty_values:
                        # Progress bar stuff
                        percent_done = current_step / total_steps * 100
                        self._logging.info("MIDI Note: {}, Piezo: {}, Boost: {}, {:.1f}% done".format(midi, piezo, boost, percent_done))
                        if self._gui:
                            self._gui.update_test_progress(percent_done)
                        
                        # The actual communicating and testing part
                        sound_boost_data.append(self._get_data_point(midi, boost, piezo))

                        # Other housekeeping
                        current_step += 1
                        if self._abort:
                            self._logging.info("Aborting the test")
                            self._shutdown(False)
                            return

                    sound_midi_data.append(sound_boost_data)
                
                # Let the horn cool off
                self._logging.info("Stopping for a few seconds to let the horn cool off")
                self._shut_up()
                time.sleep(10)

                # Save and make a backup copy of the data
                sound_data.append(sound_midi_data)
                data_manager.set_sound_data(sound_data)
                data_manager.save_data(backup=True)

            # Finished the test successfully
            self._shutdown()
            self._logging.info("Finished the test successfully", True)

    def get_serial_ports(self):
        """Returns a list of serial ports.
        Based off https://stackoverflow.com/a/67519864
        """
        return [i.device for i in serial.tools.list_ports.comports()]
    
    def close_port(self):
        if self._serial_port.isOpen():
            self._logging.info("Closing the serial port")
            self._serial_port.close()
    
    def abort_test(self):
        """Sets the flag to stop testing
        """
        self._abort = True
    
    def midi_to_freq(self, midi):
        # Useful resource for midi note and frequencies: https://newt.phys.unsw.edu.au/jw/notes.html
        return 2**((midi-69)/12) * 440

    def midi_to_counter_top(self, midi):
        return round(BikeHornInterface.CLOCK/BikeHornInterface.TIMER_1_PRESCALER/self.midi_to_freq(midi))

    def duty_to_counter_compare(self, duty, counter_top):
        return round(counter_top * duty / 100)

    def _get_data_point(self, midi, boost, piezo):
        if self._serial_port.isOpen():
            # Write to serial port
            t1_top = self.midi_to_counter_top(midi)
            t1_compare = self.duty_to_counter_compare(piezo, t1_top)
            t2_compare = self.duty_to_counter_compare(boost, BikeHornInterface.TIMER_2_TOP)
            self._serial_port.write("~`~`p{}~{}~{}`~`~".format(t1_top, t1_compare, t2_compare).encode('UTF-8'))
            
            # Wait for acknowledge
            response = self._serial_port.read_until("`~`~".encode('UTF-8'))
            if "~`~`Ack`~`~" not in str(response):
                self._logging.error("Lost connection to horn - no acknowledge received")
                self.abort_test()
                return 0
            
            time.sleep(0.2) # A short while to let things stabilise
            return self._audio.get_level()
        else:
            self._logging.error("Lost connection to horn - serial port closed unexpectedly")
            self.abort_test()


    def _start_test(self):
        self._logging.info("Opening the serial port")
        try:
            self._serial_port.open()
        except SerialException:
            msg = "Could not open serial port"
            self._logging.warning(msg)
            return
        
        if self._serial_port.isOpen():
            response = self._serial_port.read_until("`~`~".encode('UTF-8'))
            print(response)
            if "~`~`Ready`~`~" not in str(response):
                # Failure
                self._logging.error("Did not get a response from the the horn")
                self.abort_test()
        else:
            # Port closed
            self._logging.error("Serial port is closed")
            self.abort_test()
    
    def _shut_up(self, require_response=True):
        if self._serial_port.isOpen():
            self._serial_port.write("~`~`s`~`~".encode('UTF-8'))
        
            # Wait for acknowledge
            if require_response:
                response = self._serial_port.read_until("`~`~".encode('UTF-8'))
                if "~`~`Ack`~`~" not in str(response):
                    self._logging.error("Lost connection to horn - no acknowledge received")
                    self.abort_test()
        elif require_response:
            self._logging.error("Lost connection to horn - serial port closed unexpectedly")
            self.abort_test()

    def _shutdown(self, success=True):
        """Attempts to make the horn go quiet"""
        self._logging.info("Attempted to shut down")
        self._shut_up(False)
        if self._serial_port.isOpen():
            self._logging.info("Closing the serial port")
            try:
                self._serial_port.close()
            except SerialException:
                msg = "Could not close serial port"
                self._logging.warning(msg)
                return
        
        if self._gui:
            self._gui.test_finished(success)

class LinearFunction():
    """Class for a linear function
    """
    def __init__(self, gradient, x0, y0):
        self.m = gradient
        self.c = y0-gradient*x0
    
    def apply(self, x):
        return self.m * x + self.c

    def __str__(self):
        return "{:>6.2f}*x + {:>6.2f}".format(self.m, self.c)

class PiecewiseLinear():
    """Class for piecewise linear functions"""
    def __init__(self, fit, n_breakpoints):
        """Loads fit data in dictionary form from piecewise linear regression"""
        self._functions = []
        # Function to the left of the first breakpoint
        self._functions.append((LinearFunction(self._get_est(fit, "alpha1"), 0, self._get_est(fit, "const")), 0))
        for i in range(n_breakpoints):
            gradient = self._get_est(fit, "alpha{}".format(i+2))
            x0 = self._get_est(fit, "breakpoint{}".format(i+1))
            y0 = self._functions[i][0].apply(x0)
            function = LinearFunction(gradient, x0, y0)
            self._functions.append((function, x0))

    def apply(self, x: float) -> float:
        """Applies the piecewise function to the given number

        Args:
            x (float): Input number

        Returns:
            float: f(x) (i.e. the result)
        """
        return self.function_for_given(x).apply(x)

    def function_for_given(self, x:float) -> LinearFunction:
        """Returns the LinearFunction that would be used for a given number

        Args:
            x (number): The given number

        Returns:
            LinearFunction: The function that would be used when evaluating
        """
        for i in range(len(self._functions)-1):
            if x < self._functions[i+1][1]:
                # Found the corresponding function
                return self._functions[i][0]
        
        # Else clause
        return self._functions[-1][0]

    def _get_est(self, fit, key):
        return fit["estimates"][key]["estimate"]

    def __str__(self):
        result = []
        for i in range(len(self._functions)):
            if i == len(self._functions) // 2:
                # Draw 'f(x) = ' instead of spaces
                result.append("f(x) = {")
            else:
                result.append("       {")
            
            result.append(str(self._functions[i][0]))
            length = len(result)
            if(i == 0):
                # x < x0
                result.append(", x < {:>6.2f}\n".format(self._functions[i+1][1]))
            elif(i != len(self._functions)-1):
                # x0 <= x < x1
                result.append(", {:>6.2f} <= x < {:>6.2f}\n".format(self._functions[i][1], self._functions[i+1][1]))
            else:
                # x >= x0
                result.append(", x >= {:>6.2f}".format(self._functions[i][1]))
        return "".join(result)



class Optimiser():
    def __init__(self, logging, data_manager:DataManager, bike_horn:BikeHornInterface, gui=None):
        self._data_manager = data_manager
        self._logging = logging
        self._bike_horn = bike_horn
        self._gui = gui
        self._call_on_recalculate = []
        self._data_manager.register_call_on_update(self._recalculate, True, False)
        self._best_boost_duty = []
        self._best_piezo_duty = []
        self._best_loudness = np.empty(1)
    
    def set_gui(self, gui=None):
        self._gui = gui

    def register_call_on_recalculate(self, method):
        self._call_on_recalculate.append(method)
    
    def _recalculate(self):
        sound_data = np.array(self._data_manager.get_sound_data())

        # Calculate and display the best coordinates
        self._best_boost_duty = [0] * len(sound_data)
        self._best_piezo_duty = [0] * len(sound_data)
        self._best_loudness = np.empty(len(sound_data))

        boost_range = self._data_manager.get_boost_range()
        piezo_range = self._data_manager.get_piezo_range()
        if boost_range is not None and piezo_range is not None:
            for i in range(len(sound_data)):
                boost_index, piezo_index = np.unravel_index(np.argmax(sound_data[i], axis=None), sound_data[i].shape)
                self._best_boost_duty[i] = boost_range[boost_index]
                self._best_piezo_duty[i] = piezo_range[piezo_index]
                self._best_loudness[i] = sound_data[i, boost_index, piezo_index]
        
        # Convert to piecewise functions
        

        # Call on recalculate
        for i in self._call_on_recalculate:
            i()
    
    def optimise(self):
        """Processes the data to get linear functions (time consuming)
        """
        # TODO: Set breakpoints in gui
        piezo_breakpoints = 2
        boost_breakpoints = 4
        # Try the piezo regression
        self._piezo_fit = piecewise_regression.Fit(self._data_manager.get_midi_range, self._best_piezo_duty, n_breakpoints=piezo_breakpoints)
        piezo_fit_results = self._piezo_fit.get_results()
        if piezo_fit_results["converged"]:
            # Piezo was successful. Now try the boost
            self._boost_fit = piecewise_regression.Fit(self._data_manager.get_midi_range, self._best_piezo_duty, n_breakpoints=boost_breakpoints)
            boost_fit_results = self._boost_fit.get_results()
            if not boost_fit_results["converged"]:
                self._logging.error("The boost results did not converge with {} breakpoints. Maybe try a different number?".format(boost_breakpoints))
        else:
            self._logging.error("The piezo results did not converge with {} breakpoints. Maybe try a different number?".format(piezo_breakpoints))

    def generate_piecewise(self):
        pass
        # TODO

    def get_best_boost(self):
        return self._best_boost_duty

    def get_best_piezo(self):
        return self._best_piezo_duty
    
    def get_best_loudness(self):
        return self._best_loudness
    
    def get_best_t2_compare(self):
        result = []
        for i in self._best_boost_duty:
            result.append(self._bike_horn.duty_to_counter_compare(i, BikeHornInterface.TIMER_2_TOP))

        return result
    
    def get_best_t1_compare(self):
        result = []
        t1_tops = self.get_t1_tops()
        for index, duty in enumerate(self._best_piezo_duty):
            result.append(self._bike_horn.duty_to_counter_compare(duty, t1_tops[index]))

        return result
    
    def get_t1_tops(self):
        midi_range = self._data_manager.get_midi_range()
        return [self._bike_horn.midi_to_counter_top(i) for i in midi_range]



class GUI():
    def __init__(self, logging, bike_horn:BikeHornInterface, data_manager:DataManager, optimiser:Optimiser):
        """Creates and runs the GUI
        """
        self._logging = logging
        self._bike_horn = bike_horn
        self._data_manager = data_manager
        self._optimiser = optimiser
        self._call_on_exit = []

        self._data_manager.register_call_on_update(self.set_settings, False, True)


    def draw(self):
        """Runs the main loop
        """
        # GUI Setting up
        self._root = tk.Tk()
        self._root.title("Bike Horn Optimiser Tool")
        self._root.tk.call('wm', 'iconphoto', self._root._w, tk.PhotoImage(file='icon.png'))

        # Draw the tabbed layout
        tab_control = ttk.Notebook(self._root)
        run_test_tab = ttk.Frame(tab_control)  
        tab_control.add(run_test_tab, text ='Run test / Serial', )
        save_load_tab = ttk.Frame(tab_control)
        tab_control.add(save_load_tab, text ='Save / Load results')
        view_results_tab = ttk.Frame(tab_control)
        tab_control.add(view_results_tab, text='View results')
        optimisation_tab = ttk.Frame(tab_control)
        tab_control.add(optimisation_tab, text ='Optimisation Settings')
        upload_settings_tab = ttk.Frame(tab_control)
        tab_control.add(upload_settings_tab, text ='View / Upload Optimisations')
        help_tab = ttk.Frame(tab_control)
        tab_control.add(help_tab, text="Help / About")
        tab_control.pack(expand=True, fill ='both')

        # Message output
        ttk.Label(self._root, text="Messages").pack(side=tk.LEFT, padx=10, pady=10)
        messages_frame, self._text_messages = self._draw_scrollable_text(self._root, 5)
        messages_frame.pack(expand=True, fill='x')
        
        # Fill up the tabs (after drawing the monitor so they can log to it)
        self._draw_run_test_tab(run_test_tab)
        self._draw_save_load_tab(save_load_tab)
        self._save_settings()
        self._draw_results_tab(view_results_tab)
        self._draw_optimisation_tab(optimisation_tab)
        self._draw_upload_tab(upload_settings_tab)
        self._draw_help_tab(help_tab)

        self._root.protocol("WM_DELETE_WINDOW", self._close_window)
    
    def run(self):
        # Ready for interaction
        self._root.mainloop()

    def _draw_scrollable_text(self, parent, height, disabled=True):
        """Draws a frame containing 

        Args:
            parent ([type]): [description]
            height ([type]): [description]

        Returns:
            tuple(frame, text): Frame and text widget. The frame needs to be drawn with pack or grid to show
        """
        frame = ttk.Frame(parent)
        text = tk.Text(frame, height=height, padx=5, pady=5)
        text.pack(side=tk.LEFT, expand=True, fill='x')
        scroll_bar = tk.Scrollbar(frame, orient='vertical', command=text.yview)
        scroll_bar.pack(side=tk.RIGHT, fill='y')
        text['yscrollcommand'] = scroll_bar.set
        if disabled:
            text.configure(state='disabled')
        return frame, text

    def _confirm_run_test(self):
        """Asks whether to run the test as any unsaved results and settings will be lost
        """
        result = tkmb.askyesno("Confirm run test", "Are you sure you want to run a NEW test? Any previous, unsaved results will be lost.")
        if result:
            try:
                # +1 as people would expect top value to be included
                piezo_range = range(int(self._piezo_duty_min_text.get()), int(self._piezo_duty_max_text.get())+1, int(self._piezo_duty_inc_text.get()))
                boost_range = range(int(self._boost_duty_min_text.get()), int(self._boost_duty_max_text.get())+1, int(self._boost_duty_inc_text.get()))
                midi_range = range(int(self._midi_min_text.get()), int(self._midi_max_text.get())+1, int(self._midi_inc_text.get()))
            except ValueError:
                self._logging.error("Error interpreting test parameters as integers")
            else:
                self._save_settings()
                self._bike_horn.set_serial_port(self._serial_port.get())
                test_thread = threading.Thread(target=self._bike_horn.run_test, args=(piezo_range, boost_range, midi_range), daemon=True)
                test_thread.start()
                self._test_control_button['text'] = "ABORT Test"
                self._test_control_button['command'] = self._confirm_abort_test
                # TODO: Grey out settings
    
    def _confirm_abort_test(self):
        """Confirms the user is sure they want to abort the test"""
        result = tkmb.askokcancel("Abort the test", "Are you sure you can to abort the test? Any results up until the current note can be saved later")
        if result:
            self._bike_horn.abort_test()
    
    def test_finished(self, success):
        self._test_control_button['text'] = "Start Test"
        self._test_control_button['command'] = self._confirm_run_test

        # Set the progress bar to 0 if note successful or make sure it is at the end if success
        if success:
            self.update_test_progress(1)
        else:
            self.update_test_progress(0)

    def update_test_progress(self, value):
        self._root.update_idletasks()
        self._test_progress['value'] = value
    
    def info_dialog(self, msg=""):
        tkmb.showinfo("Info", msg)

    def warning_dialog(self, msg=""):
        tkmb.showwarning("Warning", msg)
    
    def error_dialog(self, msg=""):
        tkmb.showerror("Error", msg)

    def add_monitor_text(self, msg="", end="\n"):
        fully_scrolled_down = self._text_messages.yview()[1] == 1.0 # Scrolling based off https://stackoverflow.com/a/51781603
        self._text_messages.configure(state='normal')
        self._text_messages.insert('end', "{}{}".format(msg,end))
        self._text_messages.configure(state='disabled')
        if fully_scrolled_down:
            self._text_messages.see("end")

    def set_sound_level(self, level):
        try:
            self._root.update_idletasks()
            self._sound_progress['value'] = level
        except RuntimeError:
            print("RuntimeError when setting the sound level, possibly due to an interrupt. Stopping the audio")
            raise sd.CallbackAbort()

    def add_to_call_on_exit(self, method):
        """Adds a method that will be called when the gui window is closed

        Args:
            method (method): Method to call
        """
        self._call_on_exit.append(method)

    def set_settings(self):
        """Sets the settings
        """
        settings = self._data_manager.get_settings()
        self._logging.info("Restoring the settings: {}".format(settings))
        try:
            self._serial_port.set(settings["serial_port"])
            self._piezo_duty_min_text.set(settings["piezo_duty_min"])
            self._piezo_duty_max_text.set(settings["piezo_duty_max"])
            self._piezo_duty_inc_text.set(settings["piezo_duty_inc"])
            self._boost_duty_min_text.set(settings["boost_duty_min"])
            self._boost_duty_max_text.set(settings["boost_duty_max"])
            self._boost_duty_inc_text.set(settings["boost_duty_inc"])
            self._midi_min_text.set(settings["midi_note_min"])
            self._midi_max_text.set(settings["midi_note_max"])
            self._midi_inc_text.set(settings["midi_note_inc"])
        except KeyError:
            self._logging.warning("A key could not be found when restoring settings")
    
    def _save_settings(self):
        """Saves the settings"""
        try:
            settings = {
                "serial_port": self._serial_port.get(),
                "piezo_duty_min": int(self._piezo_duty_min_text.get()),
                "piezo_duty_max": int(self._piezo_duty_max_text.get()),
                "piezo_duty_inc": int(self._piezo_duty_inc_text.get()),
                "boost_duty_min": int(self._boost_duty_min_text.get()),
                "boost_duty_max": int(self._boost_duty_max_text.get()),
                "boost_duty_inc": int(self._boost_duty_inc_text.get()),
                "midi_note_min": int(self._midi_min_text.get()),
                "midi_note_max": int(self._midi_max_text.get()),
                "midi_note_inc": int(self._midi_inc_text.get()),
            }
        except ValueError:
            self._logging.error("Could not save the current settings - are all numbers proper integers?")
        else:
            self._data_manager.set_settings(settings)

    def _draw_run_test_tab(self, tab):
        # Serial port
        ports = self._bike_horn.get_serial_ports()
        self._serial_port = tk.StringVar(self._root)
        ttk.Label(tab, text="Serial port:").grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)
        self._logging.info("Serial ports found: {}".format(ports))
        default = ports[0] if len(ports) else "No serial ports found"
        self._serial_port_dropdown = ttk.OptionMenu(tab, self._serial_port, default, *ports)
        self._serial_port_dropdown.grid(column=1, row=0, padx=10, pady=10, sticky=tk.EW, columnspan=3)
        # TODO: Refresh button

        # Sound device
        ttk.Label(tab, text="Audio level (preview):").grid(row=1, column=0, padx=10, pady=10, sticky=tk.W)
        self._sound_progress = ttk.Progressbar(tab, orient=tk.HORIZONTAL, mode='determinate')
        self._sound_progress.grid(column=1, row=1, columnspan=3, sticky=tk.NSEW, padx=10, pady=10)

        # Sweep settings
        # TODO: Move increments to inline with their respective field
        ttk.Label(tab, text="Piezo duty min (%):").grid(row=2, padx=10, pady=10, sticky=tk.W)
        self._piezo_duty_min_text = tk.StringVar(value=5)
        piezo_duty_min_spinbox = ttk.Spinbox(tab, from_=0, to=100, textvariable=self._piezo_duty_min_text)
        piezo_duty_min_spinbox.grid(row=2, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Piezo duty max (%):").grid(row=2, column=2, padx=10, pady=10, sticky=tk.W)
        self._piezo_duty_max_text = tk.StringVar(value=75)
        piezo_duty_max_spinbox = ttk.Spinbox(tab, from_=0, to=100, textvariable=self._piezo_duty_max_text)
        piezo_duty_max_spinbox.grid(row=2, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Boost duty min (%):").grid(row=3, padx=10, pady=10, sticky=tk.W)
        self._boost_duty_min_text = tk.StringVar(value=40)
        boost_duty_min_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._boost_duty_min_text)
        boost_duty_min_spinbox.grid(row=3, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="Boost duty max (%):").grid(row=3, column=2, padx=10, pady=10, sticky=tk.W)
        self._boost_duty_max_text = tk.StringVar(value=90)
        boost_duty_max_spinbox = ttk.Spinbox(tab,  from_=0, to=100, textvariable=self._boost_duty_max_text)
        boost_duty_max_spinbox.grid(row=3, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="MIDI note min:").grid(row=4, padx=10, pady=10, sticky=tk.W)
        self._midi_min_text = tk.StringVar(value=20)
        midi_min_spinbox = ttk.Spinbox(tab,  from_=0, to=127, textvariable=self._midi_min_text)
        midi_min_spinbox.grid(row=4, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(tab, text="MIDI note max:").grid(row=4, column=2, padx=10, pady=10, sticky=tk.W)
        self._midi_max_text = tk.StringVar(value=127)
        midi_max_spinbox = ttk.Spinbox(tab,  from_=0, to=127, textvariable=self._midi_max_text)
        midi_max_spinbox.grid(row=4, column=3, padx=10, pady=10, sticky=tk.W)
        # Increments (6 columns)
        increments_frame = tk.Frame(tab)
        ttk.Label(increments_frame, text="Piezo duty increment (%):").grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)
        self._piezo_duty_inc_text = tk.StringVar(value=5)
        piezo_duty_inc_spinbox = ttk.Spinbox(increments_frame,  from_=0, to=100, textvariable=self._piezo_duty_inc_text, width=10)
        piezo_duty_inc_spinbox.grid(row=0, column=1, padx=10, pady=10, sticky=tk.W)
        ttk.Label(increments_frame, text="Boost duty increment (%):").grid(row=0, column=2, padx=10, pady=10, sticky=tk.W)
        self._boost_duty_inc_text = tk.StringVar(value=5)
        boost_duty_inc_spinbox = ttk.Spinbox(increments_frame,  from_=0, to=100, textvariable=self._boost_duty_inc_text, width=10)
        boost_duty_inc_spinbox.grid(row=0, column=3, padx=10, pady=10, sticky=tk.W)
        ttk.Label(increments_frame, text="MIDI note increment:").grid(row=0, column=4, padx=10, pady=10, sticky=tk.W)
        self._midi_inc_text = tk.StringVar(value=5)
        midi_inc_spinbox = ttk.Spinbox(increments_frame,  from_=0, to=100, textvariable=self._midi_inc_text, width=10)
        midi_inc_spinbox.grid(row=0, column=5, padx=10, pady=10, sticky=tk.W)
        increments_frame.grid(row=5, column=0, columnspan=4, sticky=tk.NSEW)

        # Run test and progress bar
        self._test_control_button = ttk.Button(tab, text="Start test", command=self._confirm_run_test)
        self._test_control_button.grid(row=6, padx=10, pady=10, columnspan=4, sticky=tk.NSEW)

        self._test_progress = ttk.Progressbar(tab, orient=tk.HORIZONTAL, mode='determinate', length=800)
        self._test_progress.grid(column=0, row=7, columnspan=4, sticky=tk.NSEW, padx=10, pady=10)

    def _draw_save_load_tab(self, tab):
        ttk.Label(tab, text="Current file:").grid(row=0, column=0, sticky=tk.W, padx=10, pady=10)
        self._current_file_text = tk.Text(tab, width=70, height=2, padx=5, pady=5)
        self._current_file_text.grid(row=0, column=1, sticky=tk.NSEW, padx=10, pady=10)
        self._replace_text_contents(self._current_file_text, self._data_manager.get_filename())
        ttk.Button(tab, text="Open", command=self._select_open_file).grid(row=0, column=3, padx=10, pady=10, sticky=tk.E)
        ttk.Button(tab, text="Save as", command=self._select_save_file).grid(row=0, column=4, padx=10, pady=10, sticky=tk.E)

        # TODO: Show metadata and settings - possibly in a text box

    def _draw_results_tab(self, tab):
        self._results_fig = Figure()
        # Based of various examples
        self._ax_loudness = self._results_fig.gca(projection='3d')
        self._results_cur_value = 0
        self._data_manager.register_call_on_update(self._plot_results, True, False)
        self._data_manager.register_call_on_update(self._update_results_scroll, True, False)

        # Based off https://www.geeksforgeeks.org/how-to-embed-matplotlib-charts-in-tkinter-gui/
        # Create the Tkinter canvas containing the Matplotlib figure
        canvas = FigureCanvasTkAgg(self._results_fig, tab)
        canvas.draw()
        canvas.get_tk_widget().pack()

        # Scroll bar
        self._results_scrollbar = ttk.Scrollbar(tab, orient='horizontal', command=self._plot_results_scroll)
        self._results_scrollbar.pack(fill='x')
        
        # Create the Matplotlib toolbar
        toolbar = NavigationToolbar2Tk(canvas, tab)
        toolbar.update()
        canvas.get_tk_widget().pack()
    
    def _draw_optimisation_tab(self, tab):
        self._optimiser_show_counters = tk.IntVar()
        self._optimiser_fig = Figure()
        self._optimiser_fig.suptitle("Parameters for best performance of each note")
        self._ax_boost_best = self._optimiser_fig.add_subplot(2, 1, 1)
        self._ax_piezo_best = self._optimiser_fig.add_subplot(2, 1, 2)
        self._plot_optimisation()
        self._optimiser_fig.subplots_adjust(hspace=0.5)
        canvas = FigureCanvasTkAgg(self._optimiser_fig, tab)
        canvas.draw()
        canvas.get_tk_widget().pack()
        tk.Checkbutton(tab, text="Show timer values", variable=self._optimiser_show_counters, command=self._plot_optimisation).pack(fill='x')
        self._optimiser.register_call_on_recalculate(self._plot_optimisation)
        # Create the Matplotlib toolbar
        toolbar = NavigationToolbar2Tk(canvas, tab)
        toolbar.update()
        canvas.get_tk_widget().pack()

    def _draw_help_tab(self, tab):
        ttk.Label(tab, text="Bike Horn Optimiser version {}\nBy Jotham Gates\nThis is still a work in progress. For more info, go to:".format(version)).grid(row=0, column=0, padx=10, pady=(10, 0), sticky=tk.W)
        # Link based off https://stackoverflow.com/a/23482749
        github = "https://github.com/jgOhYeah/BikeHorn"
        github_link = ttk.Label(tab, text=github, cursor="hand2", foreground="blue")
        github_link.grid(padx=10, pady=(0, 10), sticky=tk.W, row=1, column=0)
        github_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab(github))
        ttk.Label(tab, text="MAIN STEPS:\n1. Upload the optimising sketch to the horn.\n2. Run or open a test.\n3. Upload the optimised settings to the horn.\n4. Upload the main bike horn sketch to put the horn back in power saving mode.").grid(padx=10, pady=10, row=2, column=0, sticky=tk.W)
    
    def _draw_upload_tab(self, tab):
        ttk.Label(tab, text="Optimal timer 1 (piezo) compare as a function of timer 1 top").grid(row=0, column=0, padx=10, pady=10, sticky=tk.W)
        frame, self._timer1_human_readable = self._draw_scrollable_text(tab, 5)
        frame.grid(row=1, sticky=NSEW, padx=10, pady=(0, 10))
        ttk.Label(tab, text="Optimal timer 2 (boost) compare as a function of timer 1 top").grid(row=2, column=0, padx=10, pady=10, sticky=tk.W)
        frame, self._timer2_human_readable = self._draw_scrollable_text(tab, 5)
        frame.grid(row=3, sticky=NSEW, padx=10, pady=(0, 10))
        ttk.Label(tab, text="Raw settings that will be uploaded").grid(row=4, column=0, padx=10, pady=10, sticky=tk.NSEW)
        frame, self._to_upload_text = self._draw_scrollable_text(tab, 7)
        frame.grid(row=5, sticky=NSEW, padx=10, pady=(0, 10))
        ttk.Button(tab, text="Upload to horn (WHEN IMPLEMENTED)").grid(row=6, column=0, padx=10, pady=10, sticky=tk.NSEW)

    def _draw_optimised_formulas(self):
        # TODO
        pass

    def _plot_optimisation(self):
        self._ax_boost_best.clear()
        self._ax_piezo_best.clear()
        if self._optimiser_show_counters.get():
            # Show counters instead of %
            self._ax_boost_best.set_title("Optimal boost (timer 2) compare value")
            self._ax_boost_best.set_xlabel("Piezo (timer 1) top")
            self._ax_boost_best.set_ylabel("Timer 2 compare")
            self._ax_piezo_best.set_title("Optimal piezo (timer 1) compare value")
            self._ax_piezo_best.set_xlabel("Piezo (timer 1) top")
            self._ax_piezo_best.set_ylabel("Timer 1 compare")

            # TODO:
            midi = self._optimiser.get_t1_tops()[:len(self._data_manager)]
            best_boost = self._optimiser.get_best_t2_compare()
            best_piezo = self._optimiser.get_best_t1_compare()
        else:
            # Show %
            self._ax_boost_best.set_title("Optimal boost duty cycle")
            self._ax_boost_best.set_xlabel("MIDI Note")
            self._ax_boost_best.set_ylabel("Boost duty cycle [%]")
            self._ax_piezo_best.set_title("Optimal piezo duty cycle")
            self._ax_piezo_best.set_xlabel("MIDI Note")
            self._ax_piezo_best.set_ylabel("Piezo duty cycle [%]")
            midi = self._data_manager.get_midi_range()[:len(self._data_manager)]
            best_boost = self._optimiser.get_best_boost()
            best_piezo = self._optimiser.get_best_piezo()
        
        self._ax_boost_best.plot(midi, best_boost, label="Measured")
        # TODO: ax_boost_best.plot(boost_x, boost_y, color="orange", label="Map")        
        self._ax_boost_best.legend()

        self._ax_piezo_best.plot(midi, best_piezo, label="Measured")
        # TODO: ax_piezo_best.plot(piezo_x, piezo_y, color="orange", label="Map")
        self._ax_piezo_best.legend()

        self._optimiser_fig.canvas.draw_idle()

    def _plot_results_scroll(self, instruction=None, amount=None, units=None):
        max_index = len(self._data_manager.get_sound_data())-1
        if instruction == tk.SCROLL:
            amount = int(amount)
            # Move one unit at a time (clicking on arrows at ends)
            if amount > 0 and self._results_cur_value < max_index:
                self._plot_results(self._results_cur_value + 1)
            if amount < 0 and self._results_cur_value > 0:
                self._plot_results(self._results_cur_value - 1)
            self._update_results_scroll()

        elif instruction == tk.MOVETO:
            # Convert float to an index
            amount = float(amount)
            max_index = len(self._data_manager.get_sound_data())-1
            amount = max(min(round(max_index*amount) / max_index, 1), 0)
            self._update_results_scroll(amount)
            if max_index >= 0:
                self._plot_results(max_index*amount)
    
    def _update_results_scroll(self, position=None):
        width = 1/max(len(self._data_manager.get_sound_data())-1, 1)
        if position is None:
            position = self._results_cur_value * width
        operating_range = 1-width
        left = min(max(position * operating_range, 0), operating_range)
        right = left + width
        self._results_scrollbar.set(left, right)

    def _plot_results(self, val=None):
        # Index to search for
        sound_data = np.array(self._data_manager.get_sound_data())
        if val is not None:
            val = int(val)
        else:
            # Not specified, if not on the last one, stay the same, otherwise go to latest
            if self._results_cur_value < len(sound_data)-2:
                val = self._results_cur_value
            else:
                val = len(sound_data)-1
        
        self._results_cur_value = val
        
        # Getting data and plotting it
        piezo_range = self._data_manager.get_piezo_range()
        if piezo_range:
            boost_range = self._data_manager.get_boost_range()
            if boost_range:
                piezo_mesh, boost_mesh = np.meshgrid(piezo_range, boost_range)

                # Update the title
                self._results_fig.suptitle("Performance for midi note {}".format(self._data_manager.get_midi_range()[val]))

                # Process data and get the maximum and minimum
                sound_data = np.array(self._data_manager.get_sound_data())
                loudness = sound_data[val]

                # Display subplot 1
                self._ax_loudness.cla()
                self._ax_loudness.set_xlabel("Piezo Duty Cycle [%]")
                self._ax_loudness.set_ylabel("Boost Duty Cycle [%]")
                self._ax_loudness.set_zlabel("Loudness")
                self._ax_loudness.plot_surface(piezo_mesh, boost_mesh, loudness, color="b")
                self._ax_loudness.set_xlim3d(piezo_mesh[0,0], piezo_mesh[-1,-1])
                self._ax_loudness.set_ylim3d(boost_mesh[0,0], boost_mesh[-1,-1])

                # Update
                self._results_fig.canvas.draw_idle()

    def _replace_text_contents(self, widget, text):
        widget.configure(state='normal')
        widget.delete('1.0', 'end')
        widget.insert('end', text)
        widget.configure(state='disabled')

    def _select_save_file(self):
        self._data_manager.get_filename()
        filename = fd.asksaveasfilename(defaultextension="npz", initialfile=self._data_manager.get_filename())
        if type(filename) == str:
            self._logging.info("Filename to use is: '{}'".format(filename))
            self._replace_text_contents(self._current_file_text, filename)
            self._data_manager.set_filename(filename)
            self._save_settings()
            self._data_manager.save_data()
        else:
            self._logging.info("Cancelled saving file")
    
    def _select_open_file(self):
        result = tkmb.askyesno("Open an existing file", "Are you sure you want to open an existing file? Any unsaved data will be lost.")
        if result:
            filename = fd.askopenfilename(defaultextension="npz", initialfile=self._data_manager.get_filename())
            if type(filename) == str and filename != "":
                self._data_manager.open(filename)
                self._replace_text_contents(self._current_file_text, filename)
            else:
                self._logging.info("Cancelled opening file")
        else:
            self._logging.info("Cancelled opening file")


    def _close_window(self):
        """Calls everything this is meant to call before closing, then destroys the window
        """
        self._logging.info("Closing")
        for i in self._call_on_exit:
            i()
        
        # Dodgy bit to make stuff close in the right order
        self._root.destroy()

class Logging():
    """Class for logging events and displaying them in appropriate locations
    """
    def __init__(self, gui:GUI=None) -> None:
        self._gui = gui

    def set_gui(self, gui=None) -> None:
        self._gui = gui

    def info(self, msg="", end="\n", dialog=False) -> None:
        print(msg)
        if self._gui:
            self._gui.add_monitor_text(msg, end)
            if dialog:
                self._gui.info_dialog(msg)

    def warning(self, msg="") -> None:
        warning_msg = "WARNING: {}".format(msg)
        print(warning_msg)
        if self._gui:
            self._gui.add_monitor_text(warning_msg)
            # self.gui.warning_dialog(msg)
    
    def error(self, msg="") -> None:
        error_msg = "ERROR: {}".format(msg)
        print(error_msg)
        if self._gui:
            self._gui.add_monitor_text(error_msg)
            self._gui.error_dialog(msg)

class AudioLevels():
    def __init__(self, gui:GUI=None):
        self._audio_level = 0
        self._stream = sd.InputStream(callback=self._audio_callback, blocksize=500)
        self.set_gui(gui)
        self._stop_required = False

    def set_gui(self, gui=None) -> None:
        self._gui = gui
        if self._gui:
            self._gui.add_to_call_on_exit(self.stop)

    def start(self):
        self._stop_required = False
        self._stream.start()

    def stop(self):
        # Make stopping part of the callback as otherwise it seems to lock up occasionally
        print("Audio stop required")
        self._stop_required = True

        # Wait until we know it stops
        while self._stop_required:
            time.sleep(0.1)
    
    def get_level(self):
        return self._audio_level

    def _audio_callback(self, indata, frames, time, status):
        if self._stop_required:
            print("Stopping audio")
            self._stop_required = False
            raise sd.CallbackAbort()
        
        self._audio_level = np.linalg.norm(indata) * 10
        if self._gui:
            self._gui.set_sound_level(self._audio_level)

if __name__ == "__main__":
    logging = Logging()
    data_manager = DataManager(logging)
    bike_horn = BikeHornInterface(logging, data_manager)
    optimiser = Optimiser(logging, data_manager, bike_horn)
    gui = GUI(logging, bike_horn, data_manager, optimiser)
    optimiser.set_gui(gui)
    bike_horn.set_gui(gui)
    audio = AudioLevels(gui)
    bike_horn.set_audio(audio)
    logging.set_gui(gui)
    gui.draw()
    audio.start()
    gui.run()